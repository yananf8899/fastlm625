has_wait_in_dir <- function(dir, pos, time) {
if (dir == 1L) {
any(waiting & (t_req <= time) & (wdir == 1L) & (s > pos))
} else {
any(waiting & (t_req <= time) & (wdir == -1L) & (s < pos))
}
}
has_rider_in_dir <- function(dir, pos) {
if (dir == 1L) {
any(riding & (d > pos))
} else {
any(riding & (d < pos))
}
}
while (any(!done)) {
stopped <- FALSE
# 1. 让该下的人下
exit_idx <- which(riding & d == pos)
if (length(exit_idx)) {
riding[exit_idx] <- FALSE
done[exit_idx]   <- TRUE
stopped <- TRUE
}
# 2. 看现在这一刻已经到的乘客
active_wait <- waiting & (t_req <= time)
here_idx    <- which(active_wait & s == pos)
if (length(here_idx)) {
# 电梯空的 → 可以用他们的方向来定当前方向
if (!any(riding)) {
dir <- wdir[here_idx[1L]]
}
# 只上和电梯同方向的
board_idx <- here_idx[wdir[here_idx] == dir]
if (length(board_idx)) {
waiting[board_idx] <- FALSE
riding[board_idx]  <- TRUE
stopped <- TRUE
}
}
# 3. 如果刚才有开门/上下客，要花1个时间单位，期间来的也能上（下轮再处理）
if (stopped) {
time <- time + 1
next
}
# 4. 没有停靠的话，看怎么走
if (any(riding)) {
# 有人 → 按规则先往当前方向走到底
if (has_rider_in_dir(dir, pos) || has_wait_in_dir(dir, pos, time)) {
pos  <- pos + dir
time <- time + 1
next
}
# 当前方向没人了，看看反方向
opp <- -dir
if (has_rider_in_dir(opp, pos) || has_wait_in_dir(opp, pos, time)) {
dir  <- opp
pos  <- pos + dir
time <- time + 1
next
}
# 实在没人，但还有没到时间的请求 → 跳时间
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
} else {
# 电梯空的 → 去离自己最近的已经出现的请求
active_wait <- waiting & (t_req <= time)
if (any(active_wait)) {
floors <- s[active_wait]
k <- which.min(abs(floors - pos))
target_floor <- floors[k]
if (target_floor > pos) {
dir <- 1L
pos <- pos + 1L
} else if (target_floor < pos) {
dir <- -1L
pos <- pos - 1L
} else {
# 正好在这一层，会在下一轮被上客处理
}
time <- time + 1
next
}
# 没有已到达的请求 → 跳到最近的将来请求的时间
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
}
}
time
}
elevator(matrix(c(1, 1, 2), 1, 3))            # 4
elevator(matrix(c(1, 2, 3, 1.5, 3, 2), 2, 3))  # 7
elevator <- function(x) {
x <- as.matrix(x)
if (ncol(x) != 3) stop("x must be an n x 3 matrix")
n  <- nrow(x)
t_req <- as.numeric(x[, 1])
s     <- as.numeric(x[, 2])
d     <- as.numeric(x[, 3])
waiting <- rep(TRUE, n)
riding  <- rep(FALSE, n)
done    <- rep(FALSE, n)
time <- 0
pos  <- 1
dir  <- 1
sgn <- function(z) ifelse(z > 0, 1L, ifelse(z < 0, -1L, 0L))
has_wait_same_dir_ahead <- function(dir, pos, time) {
if (dir == 1L) {
any(waiting & t_req <= time & s > pos & sgn(d - s) == 1L)
} else {
any(waiting & t_req <= time & s < pos & sgn(d - s) == -1L)
}
}
has_rider_ahead <- function(dir, pos) {
if (dir == 1L) {
any(riding & d > pos)
} else {
any(riding & d < pos)
}
}
while (any(!done)) {
stopped <- FALSE
## 1) 先让要下的人下
exit_idx <- which(riding & (d == pos))
if (length(exit_idx)) {
riding[exit_idx] <- FALSE
done[exit_idx]   <- TRUE
stopped <- TRUE
}
## 2) 再看这一刻已经到的请求能不能上
active_wait <- waiting & (t_req <= time)
here_idx    <- which(active_wait & s == pos)
if (length(here_idx)) {
if (!any(riding)) {
dir <- sgn(d[here_idx[1L]] - s[here_idx[1L]])
if (dir == 0L) dir <- 1L
}
board_idx <- here_idx[sgn(d[here_idx] - s[here_idx]) == dir]
if (length(board_idx)) {
waiting[board_idx] <- FALSE
riding[board_idx]  <- TRUE
stopped <- TRUE
}
}
## 有上下客就算开门 1 个时间单位
if (stopped) {
time <- time + 1
next
}
## 3) 没有上下客，要么走，要么等
active_wait <- waiting & (t_req <= time)
if (any(riding)) {
## 电梯里有人 → 优先保持当前方向，直到前面没人了
if (has_rider_ahead(dir, pos) || has_wait_same_dir_ahead(dir, pos, time)) {
pos  <- pos + dir
time <- time + 1
next
}
## 当前方向前面没人了，看看反方向
opp <- -dir
if (has_rider_ahead(opp, pos) || has_wait_same_dir_ahead(opp, pos, time)) {
dir  <- opp
pos  <- pos + dir
time <- time + 1
next
}
## 前后都没有，但还有没到时间的请求 → 跳时间
fut <- which(waiting & t_req > time)
if (!length(fut)) break
time <- min(t_req[fut])
next
} else {
## 电梯空
if (any(active_wait)) {
floors <- s[active_wait]
k <- which.min(abs(floors - pos))
target <- floors[k]
step_dir <- sgn(target - pos)
if (step_dir != 0L) {
dir  <- step_dir
pos  <- pos + dir
time <- time + 1
} else {
## 正好站在要上的楼层，上一轮没上成功（方向不对），这轮会被上面的逻辑处理
time <- time + 0
}
next
}
## 电梯空而且当前没人到 → 跳到最近的将来
fut <- which(waiting & t_req > time)
if (!length(fut)) break
time <- min(t_req[fut])
next
}
}
time
}
elevator(matrix(c(1, 1, 2), 1, 3))            # 4
elevator(matrix(c(1, 2, 3, 1.5, 3, 2), 2, 3))  # 7
elevator(matrix(c(1, 1, 2), 1, 3))
elevator(matrix(c(1, 2, 3, 1.5, 3, 2), 2, 3))
elevator <- function(x) {
x <- as.matrix(x)
if (ncol(x) != 3) stop("x must be an n x 3 matrix")
n <- nrow(x)
t_req <- as.numeric(x[,1])
s     <- as.integer(x[,2])
d     <- as.integer(x[,3])
waiting <- rep(TRUE, n)
riding  <- rep(FALSE, n)
done    <- rep(FALSE, n)
time <- 0
pos  <- 1L
dir  <- 1L
sgn <- function(z) ifelse(z > 0, 1L, ifelse(z < 0, -1L, 0L))
# helper: active (arrived) waiters at current time
active_wait_idx <- function(cur_time) which(waiting & (t_req <= cur_time))
# helper: any waiting ahead in given direction with same desired direction
any_wait_ahead_same_dir <- function(cur_dir, cur_pos, cur_time) {
idx <- which(waiting & (t_req <= cur_time))
if (length(idx) == 0) return(FALSE)
if (cur_dir == 1L) {
any(s[idx] > cur_pos & (d[idx] - s[idx]) > 0)
} else {
any(s[idx] < cur_pos & (d[idx] - s[idx]) < 0)
}
}
# helper: any riders ahead in given direction
any_rider_ahead <- function(cur_dir, cur_pos) {
if (cur_dir == 1L) any(riding & d > cur_pos) else any(riding & d < cur_pos)
}
# main loop: finish when all done
while (any(!done)) {
# 1) process exits at current floor
exit_idx <- which(riding & (d == pos))
stopped <- FALSE
if (length(exit_idx) > 0) {
riding[exit_idx] <- FALSE
done[exit_idx]   <- TRUE
stopped <- TRUE
}
# 2) process boarding at current floor for those already arrived (t_req <= time)
arrived_idx <- which(waiting & (t_req <= time) & s == pos)
if (length(arrived_idx) > 0) {
# if elevator empty, pick direction from earliest-arrived at this floor (tie: pick first)
if (!any(riding)) {
# pick first arrived's desired direction
pick <- arrived_idx[which.min(t_req[arrived_idx])]
dir <- sgn(d[pick] - s[pick])
if (dir == 0L) dir <- 1L
}
# board only those whose desired direction equals current dir
board_idx <- arrived_idx[ sgn(d[arrived_idx] - s[arrived_idx]) == dir ]
if (length(board_idx) > 0) {
waiting[board_idx] <- FALSE
riding[board_idx]  <- TRUE
stopped <- TRUE
}
# Note: those at this floor wanting opposite direction wait
}
# If we opened doors (some exit or boarding), door takes 1 time unit.
if (stopped) {
# During this 1 unit, arrivals with t_req <= time+1 who are at same floor should be considered next loop.
time <- time + 1
next
}
# 3) decide movement
# refresh active waits
active_idx <- which(waiting & (t_req <= time))
if (any(riding)) {
# If there are riders, prefer to continue in current dir if there are riders ahead
if (any_rider_ahead(dir, pos) || any_wait_ahead_same_dir(dir, pos, time)) {
pos  <- pos + dir
time <- time + 1
next
}
# otherwise try opposite direction
if (any_rider_ahead(-dir, pos) || any_wait_ahead_same_dir(-dir, pos, time)) {
dir  <- -dir
pos  <- pos + dir
time <- time + 1
next
}
# no riders nor waits anywhere currently -> jump forward in time to next request (if exists)
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
} else {
# elevator empty
if (length(active_idx) > 0) {
# move one step toward the nearest active waiting floor
floors <- s[active_idx]
# choose nearest by distance, tie break by smaller floor (deterministic)
dists <- abs(floors - pos)
k <- which.min(dists)
target <- floors[k]
step_dir <- sgn(target - pos)
if (step_dir == 0L) {
# exactly at same floor but we didn't board due to direction mismatch;
# decide direction: pick earliest waiting at this floor's desired dir
pick <- active_idx[which.min(t_req[active_idx & s == pos])]
if (!is.na(pick)) {
dir <- sgn(d[pick] - s[pick])
if (dir == 0L) dir <- 1L
} else {
# otherwise default to up
dir <- 1L
}
# don't move this step; letting boarding logic handle next loop
# but to avoid stalling, we advance time minimally (0 -> do not advance)
# we jump into next loop to see boarding; but to prevent infinite loop, if no boarding possible, advance time to next future request.
# check if any future requests exist
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
# if next future request time equals current time (shouldn't), avoid infinite; otherwise jump
next_time <- min(t_req[fut])
if (next_time > time) {
time <- next_time
next
} else {
# safeguard
time <- time + 1
next
}
} else {
dir <- step_dir
pos  <- pos + dir
time <- time + 1
next
}
} else {
# no active waits -> jump to next request time if any
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
}
}
}
return(time)
}
elevator(matrix(c(1, 1, 2), 1, 3))            # 4
elevator(matrix(c(1, 2, 3, 1.5, 3, 2), 2, 3))  # 7
elevator <- function(x) {
x <- as.matrix(x)
if (ncol(x) != 3) stop("x must be an n x 3 matrix (each row: t_i, s_i, d_i)")
n <- nrow(x)
t_req <- as.numeric(x[,1])
s     <- as.integer(x[,2])
d     <- as.integer(x[,3])
if (any(is.na(t_req) | is.na(s) | is.na(d))) stop("NA in input")
if (any(s == d)) stop("Each request must have s != d")
if (any(s != floor(s)) || any(d != floor(d))) stop("Floor numbers must be integers")
waiting <- rep(TRUE, n)
riding  <- rep(FALSE, n)
done    <- rep(FALSE, n)
time <- 0.0
pos  <- 1L
dir  <- 1L
sgn <- function(z) ifelse(z > 0, 1L, ifelse(z < 0, -1L, 0L))
active_wait_idx <- function(cur_time) which(waiting & (t_req <= cur_time))
any_wait_ahead_same_dir <- function(cur_dir, cur_pos, cur_time) {
idx <- active_wait_idx(cur_time)
if (length(idx) == 0) return(FALSE)
if (cur_dir == 1L) {
any(s[idx] > cur_pos & (d[idx] - s[idx]) > 0)
} else {
any(s[idx] < cur_pos & (d[idx] - s[idx]) < 0)
}
}
any_rider_ahead <- function(cur_dir, cur_pos) {
if (cur_dir == 1L) any(riding & (d > cur_pos)) else any(riding & (d < cur_pos))
}
# Safe progress: each loop either advances time, moves elevator, or finishes some requests
while (any(!done)) {
# 1) people exit at current floor
exit_idx <- which(riding & (d == pos))
stopped <- FALSE
if (length(exit_idx) > 0) {
riding[exit_idx] <- FALSE
done[exit_idx]   <- TRUE
stopped <- TRUE
}
# 2) people board at current floor who have arrived (t_req <= time)
arrived_here <- which(waiting & (t_req <= time) & (s == pos))
if (length(arrived_here) > 0) {
if (!any(riding)) {
# elevator empty: pick direction from earliest-arrived at this floor (deterministic)
pick <- arrived_here[which.min(t_req[arrived_here])]
dir <- sgn(d[pick] - s[pick])
if (dir == 0L) dir <- 1L
}
# only board those going in the current direction
to_board <- arrived_here[ sgn(d[arrived_here] - s[arrived_here]) == dir ]
if (length(to_board) > 0) {
waiting[to_board] <- FALSE
riding[to_board]  <- TRUE
stopped <- TRUE
}
}
# 3) if stopped (either exit or board), opening/closing doors takes 1 time unit
if (stopped) {
time <- time + 1
next
}
# 4) decide movement or time jump
active_idx <- active_wait_idx(time)
if (any(riding)) {
# If riders exist, continue current direction if any rider ahead OR any same-direction waiting ahead
if (any_rider_ahead(dir, pos) || any_wait_ahead_same_dir(dir, pos, time)) {
pos  <- pos + dir
time <- time + 1
next
}
# else consider opposite direction
if (any_rider_ahead(-dir, pos) || any_wait_ahead_same_dir(-dir, pos, time)) {
dir  <- -dir
pos  <- pos + dir
time <- time + 1
next
}
# no riders and no active waits -> jump to next request time
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
} else {
# elevator empty
if (length(active_idx) > 0) {
# move one step toward the nearest active waiting floor (tie-break: smaller floor)
floors <- s[active_idx]
dists  <- abs(floors - pos)
k <- which.min(dists + 1e-9 * floors)  # deterministic tie-break
target <- floors[k]
step_dir <- sgn(target - pos)
if (step_dir == 0L) {
# at same floor but couldn't board due to opposite desired direction
# choose earliest at this floor, set dir accordingly, but to avoid stalling, perform one door cycle if they match
pick_here <- active_idx[ which(s[active_idx] == pos) ]
if (length(pick_here) > 0) {
pick <- pick_here[which.min(t_req[pick_here])]
newdir <- sgn(d[pick] - s[pick])
if (newdir != 0L && newdir != dir) {
# don't force direction change; just wait  -> but prevent infinite wait by advancing time to next event if necessary
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) {
# no future requests -> nothing more to do
break
} else {
time <- min(t_req[fut])
next
}
} else {
# same direction or undefined -> open doors will be handled at top of loop
# but to avoid zero-progress loop, jump to next future time
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
}
} else {
# no one exactly at this floor (shouldn't reach here), advance time
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
}
} else {
dir <- step_dir
pos <- pos + dir
time <- time + 1
next
}
} else {
# no active waits -> jump to next request time if exists
fut <- which(waiting & (t_req > time))
if (length(fut) == 0) break
time <- min(t_req[fut])
next
}
}
}
return(time)
}
elevator(matrix(c(1, 1, 2), 1, 3))
elevator(matrix(c(1, 2, 3, 1.5, 3, 2), 2, 3))
elevator ( matrix (c(1, 1.5 , 2, 3, 3, 2), 2, 3))
setwd("C:/15742/Download/R_package")
setwd("C:/Users/15742/Downloads/R_package")
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::check()
devtools::check()
usethis::use_mit_license("Student")
devtools::check()
devtools::check()
library(devtools)
devtools::test()
install.packages("usethis")
library(usethis)
usethis::use_github_action_check_standard()
usethis::use_github_actions()
usethis::use_github_action("check-release")
install.packages("usethis")
library(usethis)
usethis::use_github_action_check_standard()
usethis::use_github_actions()
